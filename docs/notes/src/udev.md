### Udev backend

> udev is a userspace system that enables the operating system administrator to register 
> userspace handlers for events. The events received by udev's daemon are mainly 
> generated by the (Linux) kernel in response to physical events relating to peripheral 
> devices. As such, udev's main purpose is to act upon peripheral detection and 
> hot-plugging, including actions that return control to the kernel, e.g., 
> loading kernel modules or device firmware. Another component of this detection is 
> adjusting the permissions of the device to be accessible to non-root users and groups.

*see: [wiki.archlinux.org/title/udev](https://wiki.archlinux.org/title/udev)*

**Preliminary observations:**

Before implementing udev backend let's take a look at the existing implementations. 
The `udev` backend module in anvil has 1660 lines of code, pinnacle and niri about 2000, 
strata doesn't have udev, cosmic also has 2000 lines plus some helpers. 

It's worth to note that other than anvil all implementation hold the udev backend state in an enum
to differentiate with winit. Anvil uses some trait bounds to make backend operation generic.

The easiest to read implementation which could serve as a reference is probably the one in cosmic. 
Note that in cosmic, udev backend is referred to as "KmsState", I don't know yet if this is accurate
and if there are many differences with the other implementations.

**Udev backend**

In the context of Smithay we can use `UdevBackend` to get notified about devices changes in 
the eventloop. Note that upon starting, we will need to get the device list once by calling 
`UdevBackend::device_list`. 

Udev event can be one of "change", "added" or "removed", each one holds a device id and the added event
has a path to the device file descriptor. 


## Glossary

**CRTC / VDC**

> A video display controller (VDC), also called a display engine or display interface, 
> is an integrated circuit which is the main component in a video-signal generator, a 
> device responsible for the production of a TV video signal in a computing or game system.

*see: [wiki/Video_display_controller](https://en.wikipedia.org/wiki/Video_display_controller)*

This is the actual hardware, smithay provide a handle to the crtc and describe it like so: 

```
//! A CRTC is a display controller provided by your device. It's primary job is
//! to take pixel data and send it to a connector with the proper resolution and
//! frequencies.
```

**DRM devices**

> The Direct Rendering Manager (DRM) is a subsystem of the Linux kernel responsible 
> for interfacing with GPUs of modern video cards.

*see: [wiki/Direct_Rendering_Manager](https://en.wikipedia.org/wiki/Direct_Rendering_Manager)*     

Looking at the anvil source, it seems those DRM device ids are converted `DrmNodes`, then to
`DrmDeviceFd` using the added path and finally to a `DrmDevice` and `GbmDevice`
then added to the compositor state. 

**GBM**

> Generic Buffer Management (GBM) is an API that provides a mechanism for allocating buffers 
> for graphics rendering tied to Mesa. GBM is intended to be used as a native platform for 
> EGL on DRM or openwfd. The handle it creates can be used to initialize EGL and to create 
> render target buffers

*see: [wiki/Mesa_(computer_graphics)](https://en.wikipedia.org/wiki/Mesa_(computer_graphics))*

**VBlank**

> VBLANK, is the time between the end of the final visible line of a frame or field 
> and the beginning of the first visible line of the next frame or field.

*see: [wiki/Vertical_blanking_interval](https://en.wikipedia.org/wiki/Vertical_blanking_interval)* 

This event is emitted By Drm device to indicate we are about to draw the next frame.